# ОПИСАНИЕ ДАТАСЕТА ДЛЯ ОБУЧЕНИЯ НЕЙРОННОЙ СЕТИ

## Общая информация

**Назначение:** Обучающие данные для нейронной сети, оценивающей качество кода Python

**Текущий размер:** 20 примеров  
**Целевой размер:** 500+ примеров

---

## Структура датасета

Каждый пример содержит:

1. **code** - исходный код Python
2. **features** - вектор из 10 признаков кода
3. **target** - целевые значения [correctness, efficiency, readability]

### Пример записи:

```json
{
  "code": "def sort_list(numbers):\n    return sorted(numbers)",
  "features": {
    "lines_of_code": 3.0,
    "functions_count": 1.0,
    "complexity": 0.1,
    "nested_levels": 0.0,
    "variable_names_length": 8.0,
    "comments_ratio": 0.33,
    "imports_count": 0.0,
    "class_count": 0.0,
    "error_handling": 0.0,
    "test_coverage": 0.0
  },
  "target": [1.0, 0.9, 0.95]
}
```

---

## Описание признаков

| № | Признак | Описание | Нормализация |
|---|---------|----------|--------------|
| 1 | lines_of_code | Количество строк кода | / 100.0 |
| 2 | functions_count | Количество функций | / 10.0 |
| 3 | complexity | Циклометрическая сложность | / 10.0 |
| 4 | nested_levels | Максимальная вложенность циклов/условий | / 5.0 |
| 5 | variable_names_length | Средняя длина имен переменных | / 20.0 |
| 6 | comments_ratio | Отношение комментариев к коду | [0, 1] |
| 7 | imports_count | Количество импортов | / 10.0 |
| 8 | class_count | Количество классов | / 5.0 |
| 9 | error_handling | Наличие обработки ошибок | 0 или 1 |
| 10 | test_coverage | Покрытие тестами | [0, 1] |

---

## Целевые значения (target)

Каждый пример имеет 3 оценки качества в диапазоне [0, 1]:

1. **Correctness (правильность)** - насколько код корректен и работоспособен
2. **Efficiency (эффективность)** - насколько эффективен алгоритм
3. **Readability (читаемость)** - насколько код понятен и читаем

### Градация качества:

- **Отличное** (0.85 - 1.0): правильный, эффективный, читаемый код
- **Хорошее** (0.65 - 0.85): работающий код с небольшими недостатками
- **Среднее** (0.45 - 0.65): код работает, но неоптимален или нечитаем
- **Плохое** (0.0 - 0.45): код с ошибками или очень плохого качества

---

## Категории задач в датасете

### Текущие категории (20 примеров):

1. **Сортировка списков** - 5 примеров
2. **Поиск элементов** - 5 примеров
3. **Работа со строками** - 5 примеров
4. **Фильтрация данных** - 5 примеров

### Планируемые категории (480+ дополнительных примеров):

1. **Работа со строками** - 60 примеров
2. **Работа со списками** - 60 примеров
3. **Работа со словарями** - 60 примеров
4. **Рекурсивные функции** - 60 примеров
5. **Циклы и итерации** - 60 примеров
6. **Условные операторы** - 60 примеров
7. **Математические функции** - 60 примеров
8. **Работа с файлами** - 30 примеров
9. **ООП (классы)** - 60 примеров
10. **Алгоритмы сортировки** - 30 примеров
11. **Алгоритмы поиска** - 30 примеров

---

## Распределение по качеству (текущее)

| Качество | Количество | Процент |
|----------|------------|---------|
| Отличное | 5 | 25% |
| Хорошее | 5 | 25% |
| Среднее | 5 | 25% |
| Плохое | 5 | 25% |

**Цель:** Сбалансированное распределение 25% / 25% / 25% / 25%

---

## Примеры кода из датасета

### Пример 1: Отличный код

```python
def sort_list(numbers):
    """Сортирует список чисел по возрастанию."""
    return sorted(numbers)
```

**Оценки:** correctness=1.0, efficiency=0.9, readability=0.95

**Почему отлично:**
- Использует встроенную функцию sorted()
- Есть docstring
- Краткий и понятный код
- Правильное именование

---

### Пример 2: Средний код

```python
def sort_list(numbers):
    result = []
    for i in range(len(numbers)):
        min_idx = i
        for j in range(i+1, len(numbers)):
            if numbers[j] < numbers[min_idx]:
                min_idx = j
        numbers[i], numbers[min_idx] = numbers[min_idx], numbers[i]
    return numbers
```

**Оценки:** correctness=0.8, efficiency=0.6, readability=0.6

**Почему средне:**
- Работает корректно
- Но сложность O(n²) вместо O(n log n)
- Нет комментариев
- Избыточный код

---

### Пример 3: Плохой код

```python
def sort_list(numbers):
    for i in range(1000):
        for j in range(1000):
            for k in range(1000):
                if numbers[i % len(numbers)] > numbers[j % len(numbers)]:
                    temp = numbers[i % len(numbers)]
                    numbers[i % len(numbers)] = numbers[j % len(numbers)]
                    numbers[j % len(numbers)] = temp
```

**Оценки:** correctness=0.1, efficiency=0.1, readability=0.3

**Почему плохо:**
- Неэффективный алгоритм O(n³)
- Избыточные циклы
- Сложность понимания
- Плохая читаемость

---

## Математическое обоснование нормализации признаков

### Зачем нормализация?

Нейронная сеть работает лучше, когда все входные данные находятся в одном диапазоне (обычно [0, 1] или [-1, 1]).

### Формула нормализации:

```
x_normalized = x_raw / x_max
```

где:
- `x_raw` - исходное значение признака
- `x_max` - максимальное ожидаемое значение
- `x_normalized` - нормализованное значение ∈ [0, 1]

### Примеры:

1. **lines_of_code** / 100.0
   - Ожидаем: код до 100 строк
   - Пример: 25 строк → 25/100 = 0.25

2. **complexity** / 10.0
   - Ожидаем: сложность до 10
   - Пример: сложность 3 → 3/10 = 0.3

3. **comments_ratio** (уже в [0, 1])
   - Процент строк с комментариями
   - Пример: 10% комментариев → 0.1

---

## Процесс подготовки данных

### 1. Сбор кода
- Написание примеров вручную
- Варианты: отличные, хорошие, средние, плохие

### 2. Анализ кода
- Парсинг с помощью модуля `ast`
- Подсчёт метрик
- Расчёт признаков

### 3. Нормализация
- Применение формул нормализации
- Приведение к диапазону [0, 1]

### 4. Разметка (labeling)
- Экспертная оценка качества
- Присвоение target значений [correctness, efficiency, readability]

### 5. Валидация
- Проверка синтаксиса кода
- Проверка корректности признаков
- Проверка балансировки датасета

---

## Разделение на выборки

После генерации полного датасета (500+ примеров):

- **Train (70%)** - обучающая выборка (~350 примеров)
- **Validation (15%)** - валидационная выборка (~75 примеров)
- **Test (15%)** - тестовая выборка (~75 примеров)

**Важно:** Разделение производится случайным образом с сохранением пропорций по категориям и уровням качества.

---

## План расширения

### Этап 1: Базовые категории
- ✅ Сортировка списков (5 примеров)
- ✅ Поиск элементов (5 примеров)
- ✅ Работа со строками (5 примеров)
- ✅ Фильтрация данных (5 примеров)

### Этап 2: Расширение (в процессе)
- ⏳ Добавить 55 примеров работы со строками
- ⏳ Добавить 60 примеров работы со списками
- ⏳ Добавить 60 примеров работы со словарями
- ⏳ Добавить 60 примеров рекурсивных функций
- ⏳ И т.д.

### Этап 3: Балансировка
- ⏳ Проверить распределение по категориям
- ⏳ Проверить распределение по качеству
- ⏳ Добавить недостающие примеры

---

## Статистика (будет обновляться)

**Версия датасета:** 0.1  
**Дата создания:** 2024  
**Последнее обновление:** [дата]

| Метрика | Значение |
|---------|----------|
| Всего примеров | 20 |
| Категорий | 4 |
| Средняя длина кода | ~6 строк |
| Средняя сложность | 0.4 |
| Баланс классов | ✅ Сбалансирован |

---

**Файл будет обновляться по мере расширения датасета.**

